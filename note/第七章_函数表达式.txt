第七章 函数表达式

函数声明:  function ｆoo() {console.log('Hcy');}  // 注意，函数声明的执行等级要比普通代码高，放在函数声明前面执行的代码能够运行
函数表达式:  var foo = function() {onsole.log('Hcy');}

    1. 递归

    函数内部使用 arguments.callee(); 可以实现对自身的调用 // 在严格模式下，不允许这么做

    使用命名函数表达式
    var factorial = ( function f(num) {
        if (num <= 1) {
            return 1;
        } else {
            return num * f(num - 1);
        }
      }
    );
    // 这样创建了一个名为  f 的命名函数表达式，然后，赋值给 factorial,即使把函数变量赋给了另一个变量， 函数 f 的名字仍然有效，在严格模式下也能通过

    2.闭包 （烦～～
    闭包： 是指有权访问另一个函数作用域中变量的函数. 比如
    function compareByProName(proName) {
            return function(object1, object2) {
                    let v1 = object1[proName];
                    let v2 = object2[proName];
                    // 不要用 return v1 - v2; 如果 v12是string ，就返回 NaN了！！！
                    if (v1 < v2) {
                            return -1;
                    } else if (v1 > v2) {
                            return 1;
                    } else {
                            return 0;
                    }
            }
    }
    return 的匿名函数，访问了外部函数 compareByProName 中的变量， proName
    细节：
    当某个函数被调用时，会创建一个执行环境(execution context)及相应的作用域链，然后， 使用 arguments 和 其他命名参数的值来初始化函数的活动对象 (activation Object)
    但在作用域链中，外部函数的活动对象始终处于第二位，再外部的函数的活动对象处于第三位；
    function compare(value1, value2){
        if (value1 < value2){
            return -1;
        } else if (value1 > value2){
            return 1;
        } else {
            return 0;
        }
    }
    var result = compare(5, 10);
    compare的执行环境(作用域链) => { // 就是作用域链，一级一级网上，最后到全局
        ① compare()的活动对象  arguments[5, 10]、value1[5]、 value2[10]
        ② 全局变量对象  compare、 result [undefined]
    }
    /**************************************/
    var compareName = compareByProName('name');
    var result = compare({name: 'hcy'}, {name: 'Greg'});
    匿名函数从 compareByProName()中返回后，它的作用域链被初始化为包含compareByProName()中的活动对象和全局变量对象。
    这样，匿名函数就能够访问 compareByProName()函数中定义的所有变量[ name ].
    更为重要的是， compareByProName()函数，执行完以后，其活动对象不会销毁，因为 匿名函数要访问 name 啊，销毁了还怎么访问
    （是指 匿名函数的作用域链仍在引用这个活动对象, 换句话说，就是， 执行完compareByProName后，执行环境的作用域链会被销毁，但，活动对象不会，因为匿名函数还要用)
    直到匿名函数销毁后，compareByProName函数的活动对象才会销毁

