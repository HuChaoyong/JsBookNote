第六章： 来了， 对象！！！
 1. 理解对象 (简单创建就不解释了 var a = new Object(); var a = {};)
        内部的特性 [attribute]  描述了 [property] 的各种特征， 不过 attribute 不能直接访问，
        规范里面把他们放在了两对儿方括号中，比如 [[Enumerable]]
        1 【数据】属性 （四个： 
        [[Configurable]] :能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性， 能否把属性修改为【访问器】属性;
        // 目前实践操作上来说，只有 delete 无法删除，其他不懂
        [[Enumberable]]:表示是否可通过for-in循环返回属性。默认true;
        [[Writable]]:表示是否可修改属性的值。默认true;
        [[Value]]:包含该属性的数据值。读取/写入都是该值; 默认为undefined;

         Configurable  设置为 false 以后， 你就再也改不回来了

        2. 【访问器】属性
        [[Configurable]] :能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性， 能否把属性修改为【访问器】属性;
        [[Enumberable]]:表示是否可通过for-in循环返回属性。默认true;
        [[Get]]： 在读取属性时调用的函数， 默认值为 undefined
        [[Set]]:  在写入属性时调用的函数， 默认值位 undefined
        访问器属性不能直接定义， 必须使用 Object.defineProperty()来定义

        var book = {
                _book: 2004,
                editioin: 1
        };
        Object.defineProperty(book, 'year', {
                get: function() { return this._year; },
                set: function() {
                        if (newValue > 2004) {
                                this._year = newValue;
                                this.editioin += newVlaue -2004;
                        }
                }
        });
        book.year = 2005;
        console.log(book.editioin);

        以上代码创建了一个book对象，定义了2个属性：_year和edition.  _year 前面的下划线是一种常用的记号，表示只能通过对象方法访问的属性
        // 如果只有 getter 就表示只能读不能写， 只有setter表示只能写不能读
        有旧方法： 
        book.__defineGetter__('year', function() {return ...});
        book.__defineSetter__('year', function() {this.* = ..});

        定义多个属性:
        Object.defineProperties(book {
                _year: {
                        value: 2004
                },
                editioin: {
                        value: 1
                },
                year: {
                        get: function() {
                                return this._year;
                        },
                        set: function(nv) {
                                if (nv > 2004) {
                                        this._year = nv;
                                        this.editioin += nv - 2004;
                                }
                        }
                }
        });
        该创建出来的 book 和上节的一样，懂了吧

        获取这些属性：
        Object.getOwnPropertyDescriptor(book, 'year'); // => 【访问器】属性 如果是数据就是 【数据】属性
        可以对任意对象 DOM 或者 BOM 使用该方法获取属性

2. 创建对象（期待得一匹）
        由于每次需要对象的时候，如果像上面一样 var book = {...}； // 代码冗余太厉害了
        于是出现了工厂模式:
        function creatPerson(name, age, job) {
                var o = new Object();
                o.name = name;
                o.age = age;
                o.job = job;
                o.sayName = function() {
                        alert(this.name);
                };
                return o;
        }
        var person1 = creatPerson('hcy', 24, 'programmer');
        // 虽然解决了代码冗余，创建对象也容易，但是，没有解决识别对象的类型、 于是就有了
        构造函数模式：
        在前面介绍过， 构造函数可以用来创建特定类型的对象， 像Object、Array这样的原生构造函数，在运行时会自动出现在执行环境中，
        此外，也可以创建自定义构造函数，从而定义对象类型和方法
        function Person(name, age, job) {
                this.name = name;
                this.age = age;
                this.job = job;
                this.sayName = function() {
                        alert(this.name);
                }
        }
        var newHcy = new Person('hcy', 24, 'Programmer');
        var newZj = new Person('zj', 23, 'Teacher');
        //对比工厂模式， 构造函数模式有这几处不同
        1.没有显式创建对象
        2.直接将属性和方法赋给了 this 对象
        3.没有 return
        // 使用 new 创建对象， 会经历以下几个步骤
        1）创建一个新对象
        2）将构造函数的作用域赋给新对象（this指向）
        3）执行构造函数中的代码（添加属性方法）
        4）返回新对象
        // newHcy 和 newZj 分别保存这Person的不同实例，但是！！！ 构造函数是一样的， 即 constructor();
        // 对象的 constructor()属性最初是用来标识对象类型的，
        // 最重要的是，自定义构造函数解决了能够标识实例类型的痛点
        newHcy.constructor === Person; // => true
        newHcy instanceof Person ; // => true

        构造函数的问题,缺陷
        1. 每次新建 Person， 都是新建一个实例，但是， 比如 sayName()，两个实例的sayName()不是同一个，但是，完成的功能是一样的
        newHcy.sayName == newZj.sayName
        创建两个完成同样任务的Function完全没必要，况且有this对象
        可以把sayName放在全局来解决这个问题
        function Person(name, age, job) {
            this.name = name;
            this.age = age;
            this.job = job;
            this.sayName = sayName;
        }
        function sayName() {
            console.log(this.name);
        }
        // 但是，这样感觉很违和啊， 你就一个 构造函数，还要依赖一个全局函数，如果Person里面的函数实例比较多，那么岂不是更蛋疼？
        // 好吧， 就用原型模式来解决这个问题